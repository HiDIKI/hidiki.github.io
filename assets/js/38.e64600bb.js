(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{245:function(t,a,s){"use strict";s.r(a);var o=s(0),v=Object(o.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"uvloop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#uvloop"}},[t._v("#")]),t._v(" * uvloop")]),t._v(" "),s("Author",{attrs:{name:"Hidekuma"}}),t._v(" "),s("p",[t._v("uvloop는 asyncio의 이벤트 루프 대체재로,  asyncio를 더 빠르게 만들고,  nodejs, gevent 및 다른 python 프레임워크와 비교해봐도, 2배이상의 퍼포먼스를 보여준다.")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("python3.5 부터 파이썬 표준 라이브러리에 추가된 asyncio는 비동기 I/O 프레임워크이다.")])]),t._v(" "),s("h2",{attrs:{id:"asyncio-uvloop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#asyncio-uvloop"}},[t._v("#")]),t._v(" asyncio & uvloop")]),t._v(" "),s("p",[t._v("asnycio는 네트워크 전송, 프로토콜 및 스트림 추상화 컬렉션과 이벤트 루프 기능이 있으며, 이벤트 루프는 asyncio의 핵심이다. asyncio의 주요기능들은 다음과 같다.")]),t._v(" "),s("ul",[s("li",[t._v("스케줄링에 의한 호출")]),t._v(" "),s("li",[t._v("네트워크를 통한 데이터 전송")]),t._v(" "),s("li",[t._v("DNS 쿼리수행")]),t._v(" "),s("li",[t._v("OS 신호 핸들링")]),t._v(" "),s("li",[t._v("서버와 커넥션을 만드는 편리한 추상화")]),t._v(" "),s("li",[t._v("비동기적 서브프로세스")])]),t._v(" "),s("p",[t._v("uvloop는 asyncio의 내장 이벤트 루프를 대체하며 설치방법 다음과 같다.")]),t._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("pip "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" uvloop\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("asyncio 코드에 uvloop를 접목하면 다음과 같다.")]),t._v(" "),s("div",{staticClass:"language-python line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" asyncio"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" uvloop\nasyncio"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("set_event_loop_policy"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("uvloop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("EventLoopPolicy"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("해당 코드는 "),s("code",[t._v("asyncio.get_event_loop()")]),t._v("를 호출하면, uvloop의 인스턴스를 리턴하게 만든다.")]),t._v(" "),s("h2",{attrs:{id:"아키텍처"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#아키텍처"}},[t._v("#")]),t._v(" 아키텍처")]),t._v(" "),s("p",[t._v("uvloop는 "),s("a",{attrs:{href:"http://libuv.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("libuv"),s("OutboundLink")],1),t._v("를 기반으로 Cython으로 작성되었다.\nlibuv는 nodejs에서 사용하는 고성능 멀티 플랫폼 비동기 I / O 라이브러리이며, 빠르고 안정적이다. nodej가 인기를 얻고 널리 보급된 이유가 libuv 덕분이라고 해도 과언이 아니다.")]),t._v(" "),s("h2",{attrs:{id:"벤치마크"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#벤치마크"}},[t._v("#")]),t._v(" 벤치마크")]),t._v(" "),s("h3",{attrs:{id:"tcp-벤치마크"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-벤치마크"}},[t._v("#")]),t._v(" TCP 벤치마크")]),t._v(" "),s("ul",[s("li",[t._v("공통조건\n"),s("ul",[s("li",[t._v("Intel Xeon CPU E5-1620 v2 @ 3.70GHz")]),t._v(" "),s("li",[t._v("Ubuntu Linux")]),t._v(" "),s("li",[t._v("1, 10, 100 KiB 크기의 메시지")]),t._v(" "),s("li",[t._v("동시성수준: 10")]),t._v(" "),s("li",[t._v("러닝타임 : 30s")])])]),t._v(" "),s("li",[t._v("asyncio, uvloop\n"),s("ul",[s("li",[t._v("Python 3.5")])])]),t._v(" "),s("li",[t._v("Go\n"),s("ul",[s("li",[t._v("GOMAXPROCS = 1")]),t._v(" "),s("li",[s("code",[t._v("net.Conn.Read/Write")]),t._v(" 호출")])])]),t._v(" "),s("li",[t._v("nodejs\n"),s("ul",[s("li",[t._v("No cluster")]),t._v(" "),s("li",[t._v("v4.2.6")])])])]),t._v(" "),s("h3",{attrs:{id:"tcp-벤치마크-결과"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-벤치마크-결과"}},[t._v("#")]),t._v(" TCP 벤치마크 결과")]),t._v(" "),s("img",{attrs:{src:t.$withBase("/uvloop/tcp-perf.png"),alt:"tcp performance"}}),t._v(" "),s("h3",{attrs:{id:"http-벤치마크"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-벤치마크"}},[t._v("#")]),t._v(" HTTP 벤치마크")]),t._v(" "),s("ul",[s("li",[t._v("조건\n"),s("ul",[s("li",[t._v("동시성수준: 300")]),t._v(" "),s("li",[t._v("러닝타임: 30s")])])])]),t._v(" "),s("h3",{attrs:{id:"http-벤치마크-결과"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-벤치마크-결과"}},[t._v("#")]),t._v(" HTTP 벤치마크 결과")]),t._v(" "),s("img",{attrs:{src:t.$withBase("/uvloop/http-perf.png"),alt:"http performance"}}),t._v(" "),s("p",[t._v("고성능 HTTP파서의 도움을 받는 asyncio는 동일한 HTTP파서를 이용하는 nodejs보다 빠르다. 심지어 uvloop를 탑재할 경우, nodejs의 약 2배,  Go와 비슷한 수준의 퍼포먼스를 보여주며 서비스 품질은 매우 우수하다고 할 수 있다.")]),t._v(" "),s("p",[t._v("httptools 기반 서버는 다른 구현과 달리 라우팅 로직을 포함하지 않아 매우 미흡하나, 해당 벤치 마크는 효율적으로 구현 된 프로토콜로 uvloop가 얼마나 빠를 수 있는지 보여주고 있다. 해당 "),s("U",[t._v("벤치마크에 영감을 받아 탄생한 Python 웹프레임워크가 바로 "),s("strong",[t._v("Sanic")])]),t._v("이다.")],1),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("aiohttp")]),t._v(" "),s("p",[t._v("aiohttp는 비동기 HTTP 서버를 asyncio를 사용하여 구현할 때 가장 많이 사용되는 프레임워크이나, HTTP parser때문에 성능 병목 현상이 발생하였다. 해당 부분을 처리하기 위해, Nginx 용으로 개발 된 nodejs HTTP 파서 C 라이브러리인 httptools를 이용하였다.")])]),t._v(" "),s("h2",{attrs:{id:"레퍼런스"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#레퍼런스"}},[t._v("#")]),t._v(" 레퍼런스")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://magic.io/blog/uvloop-blazing-fast-python-networking/",target:"_blank",rel:"noopener noreferrer"}},[t._v("uvloop: Blazing fast Python networking"),s("OutboundLink")],1)])])],1)}),[],!1,null,null,null);a.default=v.exports}}]);